//в этом примере в интерфейсе УКАЗАН тип метода, поэтому в самих методах требуется
//указывать тип возвращаемого значения и нужен return

package main

import "fmt"

type Animal interface { // объявляем интерфейс с методом MakeSound
	MakeSound() string
}

type Cat struct { // создаем структуру, к которой будет создан метод
	age  int
	name string
}

func (c Cat) MakeSound() string { // описываем метод для структуры Cat - метод с одинаковым названием !!! c Dog
	fmt.Println(c.name, c.age) // можно напрямую обращаться
	//fmt.Println("Мяу!")
	return "Мяу!"
}

type Dog struct { // создаем еще одну структуру, к которой будет создан метод
	age  int
	name string
}

func (d Dog) MakeSound() string { // описываем метод для структуры Dog - метод с одинаковым названием !!! c Cat
	fmt.Println(d.name, d.age)
	//mt.Println("Гав!")
	return "Гав!"
}

// Самое важное: методы имеют одинаковое название, но структуры могут быть совершенно разными,
// и к каждой структуре может быть привязаны методы с одинаковыми названиями. Это применимо
// когда необходимо описать для разных структур одинаковый по логике работы метод. Даже если
// структуры кардинально отличаются друг от друга.

func main() {
	var myCat Animal = Cat{5, "Puh"} // создаем переменные типа Animal с привязкой к структурам Cat, Dog
	var myDog Animal = Dog{2, "Click"}
	fmt.Println(myCat.MakeSound()) // в отличие от предыдущего примера здесь возвращается значение метода
	fmt.Println(myDog.MakeSound()) // по аналогии с работой обычной функции

}
