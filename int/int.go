//в этом примере в интерфейсе не указан тип метода, поэтому в самих методах не требуется
//указывать тип возвращаемого значения и не нужен return

package main

import "fmt"

type animal interface { // объявляем интерфейс с методом MakeSound
	MakeSound()
}

type cat struct { // создаем структуру, к которой будет создан метод
	age  int
	name string
}

func (c cat) MakeSound() { // описываем метод для структуры Cat - метод с одинаковым названием !!! c Dog
	fmt.Println(c.name, c.age) // можно напрямую обращаться
	fmt.Println("Мяу!")
}

type dog struct { // создаем еще одну структуру, к которой будет создан метод
	age  int
	name string
}

func (d dog) MakeSound() { // описываем метод для структуры Dog - метод с одинаковым названием !!! c Cat
	fmt.Println(d.name, d.age)
	fmt.Println("Гав!")
}

// Самое важное: методы имеют одинаковое название, но структуры могут быть совершенно разными,
// и как каждой структуре может быть привязаны методы с одинаковыми названиями. Это применимо
// когда необходимо описать для разных структур одинаковый по логике работы метод. Даже если
// структуры кардинально отличаются друг от друга.

func main() {
	var myCat animal = cat{5, "Puh"} // создаем переменные типа Animal с привязкой к структурам Cat, Dog
	var myDog animal = dog{2, "Click"}
	myCat.MakeSound()
	myDog.MakeSound()

}
